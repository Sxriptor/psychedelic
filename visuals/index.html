<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Consciousness - Generative Art Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: radial-gradient(ellipse at center, #001122 0%, #000000 70%);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            cursor: none;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(0, 255, 65, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 23, 68, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(33, 150, 243, 0.02) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }
        
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .tab-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 2000;
            background: rgba(0, 10, 15, 0.85);
            border: 1px solid rgba(0, 255, 65, 0.6);
            border-radius: 12px;
            backdrop-filter: blur(20px) saturate(180%);
            box-shadow: 
                0 8px 32px rgba(0, 255, 65, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .tab-container:hover {
            border-color: rgba(0, 255, 65, 0.8);
            box-shadow: 
                0 12px 40px rgba(0, 255, 65, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        
        .tabs {
            display: flex;
            background: rgba(0, 20, 0, 0.8);
        }
        
        .tab {
            padding: 8px 16px;
            border: none;
            background: transparent;
            color: #00ff41;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            border-right: 1px solid #00ff41;
            transition: all 0.3s ease;
        }
        
        .tab:last-child {
            border-right: none;
        }
        
        .tab.active {
            background: #00ff41;
            color: #000;
        }
        
        .tab:hover:not(.active) {
            background: rgba(0, 255, 65, 0.2);
        }
        
        .controls {
            color: #00ff41;
            padding: 15px;
            font-size: 11px;
            max-width: 280px;
        }
        
        .controls h3 {
            margin-bottom: 10px;
            color: #ffffff;
            text-align: center;
        }
        
        .controls div {
            margin: 5px 0;
        }
        
        .slider-container {
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider {
            flex: 1;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #00ff41;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .color-palette {
            display: flex;
            gap: 5px;
            margin: 5px 0;
        }
        
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            cursor: pointer;
            border: 2px solid transparent;
        }
        
        .color-swatch.active {
            border-color: #00ff41;
        }
        
        .button {
            background: rgba(0, 255, 65, 0.2);
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            margin: 2px;
        }
        
        .button:hover {
            background: rgba(0, 255, 65, 0.4);
        }
        
        .visual-section {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        .visual-section.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .dom-visual {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        .floating-element {
            position: absolute;
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }
        
        .matrix-rain {
            position: absolute;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #00ff41;
            animation: fall linear infinite;
            text-shadow: 0 0 5px #00ff41;
        }
        
        @keyframes fall {
            from { transform: translateY(-100vh); }
            to { transform: translateY(100vh); }
        }
        
        .geometric-grid {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 65, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 65, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridShift 10s linear infinite;
        }
        
        @keyframes gridShift {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }
        
        .particle-dom {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: particleMove 8s linear infinite;
        }
        
        @keyframes particleMove {
            0% { transform: translate(0, 0) scale(0); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translate(var(--dx), var(--dy)) scale(1); opacity: 0; }
        }
        
        .ascii-overlay {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            font-size: 8px;
            line-height: 1;
            pointer-events: none;
            opacity: 0.6;
        }
        
        .cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #00ff41;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1001;
            mix-blend-mode: difference;
        }
    </style>
</head>
<body>
    <div class="cursor" id="cursor"></div>
    
    <!-- Tab System -->
    <div class="tab-container">
        <div class="tabs">
            <button class="tab active" data-tab="canvas">Canvas Art</button>
            <button class="tab" data-tab="dom">DOM Visuals</button>
            <button class="tab" data-tab="matrix">Matrix Rain</button>
            <button class="tab" data-tab="geometric">Geometric</button>
            <button class="tab" data-tab="hybrid">Hybrid</button>
        </div>
        
        <div class="controls" id="canvasControls">
            <h3>∞ DIGITAL CONSCIOUSNESS ∞</h3>
            <div>Mode: <span id="mode">Perlin Flow</span></div>
            <div>Palette: <span id="currentPalette">Neon</span></div>
            <div class="color-palette" id="colorPalette"></div>
            
            <div class="slider-container">
                <label>Speed:</label>
                <input type="range" class="slider" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
                <span id="speedValue">1.0</span>
            </div>
            
            <div class="slider-container">
                <label>Complexity:</label>
                <input type="range" class="slider" id="complexitySlider" min="1" max="10" step="1" value="5">
                <span id="complexityValue">5</span>
            </div>
            
            <div class="slider-container">
                <label>Particles:</label>
                <input type="range" class="slider" id="particleSlider" min="100" max="5000" step="100" value="1000">
                <span id="particleValue">1000</span>
            </div>
            
            <div class="slider-container">
                <label>Zoom:</label>
                <input type="range" class="slider" id="zoomSlider" min="0.1" max="3" step="0.1" value="1">
                <span id="zoomValue">1.0</span>
            </div>
            
            <div style="margin: 10px 0;">
                <button class="button" id="audioToggle">🎵 Audio: OFF</button>
                <button class="button" id="recordBtn">📹 Record</button>
                <button class="button" id="saveBtn">💾 Save</button>
            </div>
            
            <div style="margin-top: 10px; font-size: 9px;">
                SPACE: Change Mode | 1-7: Quick Modes<br>
                MOUSE: Interactive Influence<br>
                R: Random Palette | F: Fullscreen<br>
                ESC: Reset | P: Pause
            </div>
        </div>
        
        <div class="controls" id="domControls" style="display: none;">
            <h3>∞ DOM VISUALS ∞</h3>
            <div>Elements: <span id="domElementCount">50</span></div>
            
            <div class="slider-container">
                <label>Count:</label>
                <input type="range" class="slider" id="domCountSlider" min="10" max="200" step="10" value="50">
                <span id="domCountValue">50</span>
            </div>
            
            <div class="slider-container">
                <label>Speed:</label>
                <input type="range" class="slider" id="domSpeedSlider" min="0.5" max="5" step="0.5" value="2">
                <span id="domSpeedValue">2.0</span>
            </div>
            
            <div style="margin: 10px 0;">
                <button class="button" id="domToggle">🎮 DOM: Active</button>
                <button class="button" id="resetDom">🔄 Reset</button>
            </div>
            
            <div style="margin-top: 10px; font-size: 9px;">
                CLICK: Add Elements<br>
                MOUSE: Interact with DOM<br>
                R: Random Colors
            </div>
        </div>
    </div>
    
    <!-- Visual Sections -->
    <div class="visual-section active" id="canvasSection">
        <canvas id="canvas"></canvas>
    </div>
    
    <div class="visual-section" id="domSection">
        <div class="dom-visual" id="domVisual"></div>
    </div>
    
    <div class="visual-section" id="matrixSection">
        <div class="dom-visual" id="matrixVisual"></div>
    </div>
    
    <div class="visual-section" id="geometricSection">
        <div class="dom-visual" id="geometricVisual">
            <div class="geometric-grid"></div>
        </div>
    </div>
    
    <div class="visual-section" id="hybridSection">
        <canvas id="hybridCanvas"></canvas>
        <div class="dom-visual" id="hybridDom"></div>
    </div>
    
    <div class="ascii-overlay" id="asciiArt"></div>

    <script>
        // Digital Consciousness - Generative Art Engine
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const cursor = document.getElementById('cursor');
        
        // Tab System Variables
        let currentTab = 'canvas';
        let domElements = [];
        let matrixColumns = [];
        let domElementCount = 50;
        let domSpeed = 2.0;
        let domActive = true;
        
        // Hybrid canvas
        const hybridCanvas = document.getElementById('hybridCanvas');
        const hybridCtx = hybridCanvas.getContext('2d');
        
        let width, height;
        let time = 0;
        let mouseX = 0, mouseY = 0;
        let mode = 0; // 0: Perlin Flow, 1: Fractals, 2: Optical Illusions, 3: ASCII 3D, 4: Particle Physics, 5: Plasma, 6: Neural Network
        let complexity = 5;
        let evolution = true;
        let speed = 1.0;
        let particleCount = 1000;
        let zoomLevel = 1.0;
        let currentPalette = 0;
        let audioEnabled = false;
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let frequencyData = null;
        let isRecording = false;
        let recordedFrames = [];
        
        // Color Palettes
        const colorPalettes = [
            { name: 'Neon', colors: ['#00ff41', '#ff1744', '#2196f3', '#ffeb3b', '#e91e63'] },
            { name: 'Ocean', colors: ['#006064', '#0097a7', '#00acc1', '#26c6da', '#4dd0e1'] },
            { name: 'Fire', colors: ['#ff5722', '#ff7043', '#ff8a65', '#ffab91', '#ffccbc'] },
            { name: 'Purple', colors: ['#4a148c', '#6a1b9a', '#7b1fa2', '#8e24aa', '#9c27b0'] },
            { name: 'Cosmic', colors: ['#1a237e', '#283593', '#303f9f', '#3f51b5', '#5c6bc0'] },
            { name: 'Forest', colors: ['#1b5e20', '#2e7d32', '#388e3c', '#43a047', '#4caf50'] },
            { name: 'Sunset', colors: ['#bf360c', '#d84315', '#ff5722', '#ff7043', '#ff8a65'] },
            { name: 'Monochrome', colors: ['#ffffff', '#f5f5f5', '#e0e0e0', '#bdbdbd', '#757575'] }
        ];
        
        // Particles for physics simulation
        let particles = [];
        
        // Neural network visualization
        let neurons = [];
        let connections = [];
        
        // Resize canvas
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        
        // Perlin Noise Implementation
        class PerlinNoise {
            constructor() {
                this.permutation = [];
                for (let i = 0; i < 256; i++) {
                    this.permutation[i] = Math.floor(Math.random() * 256);
                }
                this.permutation = this.permutation.concat(this.permutation);
            }
            
            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }
            
            lerp(t, a, b) {
                return a + t * (b - a);
            }
            
            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
            
            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const A = this.permutation[X] + Y;
                const AA = this.permutation[A];
                const AB = this.permutation[A + 1];
                const B = this.permutation[X + 1] + Y;
                const BA = this.permutation[B];
                const BB = this.permutation[B + 1];
                
                return this.lerp(v, 
                    this.lerp(u, this.grad(this.permutation[AA], x, y),
                                 this.grad(this.permutation[BA], x - 1, y)),
                    this.lerp(u, this.grad(this.permutation[AB], x, y - 1),
                                 this.grad(this.permutation[BB], x - 1, y - 1))
                );
            }
        }
        
        const perlin = new PerlinNoise();
        
        // Initialize color palette UI
        function initializeColorPalettes() {
            const paletteDiv = document.getElementById('colorPalette');
            colorPalettes[currentPalette].colors.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.addEventListener('click', () => {
                    // Cycle through palettes when clicking
                    currentPalette = (currentPalette + 1) % colorPalettes.length;
                    updateColorPalette();
                });
                paletteDiv.appendChild(swatch);
            });
            updateColorPalette();
        }
        
        function updateColorPalette() {
            const paletteDiv = document.getElementById('colorPalette');
            const swatches = paletteDiv.children;
            const palette = colorPalettes[currentPalette];
            
            for (let i = 0; i < swatches.length; i++) {
                swatches[i].style.backgroundColor = palette.colors[i] || '#000';
            }
            document.getElementById('currentPalette').textContent = palette.name;
        }
        
        function getColor(index, alpha = 1) {
            // Ensure currentPalette is valid
            if (!colorPalettes[currentPalette]) {
                currentPalette = 0;
            }
            
            const palette = colorPalettes[currentPalette];
            if (!palette || !palette.colors || palette.colors.length === 0) {
                return `rgba(0, 255, 65, ${alpha})`; // Fallback to green
            }
            
            // Ensure index is valid and get color
            const safeIndex = Math.abs(Math.floor(index)) % palette.colors.length;
            const color = palette.colors[safeIndex];
            
            if (!color || typeof color !== 'string') {
                return `rgba(0, 255, 65, ${alpha})`; // Fallback to green
            }
            
            // Convert hex to rgba
            const r = parseInt(color.slice(1, 3), 16) || 0;
            const g = parseInt(color.slice(3, 5), 16) || 255;
            const b = parseInt(color.slice(5, 7), 16) || 65;
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Audio Setup
        async function setupAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                microphone.connect(analyser);
                frequencyData = new Uint8Array(analyser.frequencyBinCount);
                audioEnabled = true;
                document.getElementById('audioToggle').textContent = '🎵 Audio: ON';
            } catch (error) {
                console.log('Audio access denied or not available');
            }
        }
        
        // Particle Physics System
        class Particle {
            constructor(x, y) {
                this.x = x || Math.random() * width;
                this.y = y || Math.random() * height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.life = 1.0;
                this.decay = Math.random() * 0.02 + 0.005;
                this.size = Math.random() * 4 + 1;
                this.colorIndex = Math.floor(Math.random() * colorPalettes[currentPalette].colors.length);
            }
            
            update() {
                this.x += this.vx * speed;
                this.y += this.vy * speed;
                this.life -= this.decay;
                
                // Apply audio influence
                if (audioEnabled && frequencyData) {
                    const freq = frequencyData[Math.floor(this.x / width * frequencyData.length)] / 255;
                    this.vy -= freq * 0.5;
                    this.size = 1 + freq * 5;
                }
                
                // Boundary conditions
                if (this.x < 0 || this.x > width) this.vx *= -0.8;
                if (this.y < 0 || this.y > height) this.vy *= -0.8;
                
                // Mouse attraction
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 100) {
                    this.vx += dx * 0.0001;
                    this.vy += dy * 0.0001;
                }
            }
            
            draw() {
                if (this.life <= 0) return;
                
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = getColor(this.colorIndex, this.life);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        // Initialize particles
        function initParticles() {
            particles = [];
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }
        }
        
        // Neural Network Visualization
        class Neuron {
            constructor(x, y, layer) {
                this.x = x;
                this.y = y;
                this.layer = layer;
                this.activation = Math.random();
                this.targetActivation = Math.random();
                this.size = 8 + Math.random() * 4;
            }
            
            update() {
                this.activation += (this.targetActivation - this.activation) * 0.1;
                if (Math.random() > 0.98) {
                    this.targetActivation = Math.random();
                }
                
                // Audio influence
                if (audioEnabled && frequencyData) {
                    const freq = frequencyData[this.layer * 10 % frequencyData.length] / 255;
                    this.targetActivation = Math.max(this.targetActivation, freq);
                }
            }
            
            draw() {
                const alpha = this.activation * 0.8 + 0.2;
                ctx.fillStyle = getColor(this.layer, alpha);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.activation + 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function initNeuralNetwork() {
            neurons = [];
            connections = [];
            const layers = [8, 12, 16, 12, 6];
            const layerSpacing = width / (layers.length + 1);
            const allLayerNeurons = [];
            
            // Create all neurons first
            for (let l = 0; l < layers.length; l++) {
                const layerNeurons = [];
                const neuronSpacing = height / (layers[l] + 1);
                
                for (let n = 0; n < layers[l]; n++) {
                    const neuron = new Neuron(
                        layerSpacing * (l + 1),
                        neuronSpacing * (n + 1),
                        l
                    );
                    neurons.push(neuron);
                    layerNeurons.push(neuron);
                }
                allLayerNeurons.push(layerNeurons);
            }
            
            // Create connections between layers
            for (let l = 0; l < layers.length - 1; l++) {
                const currentLayer = allLayerNeurons[l];
                const nextLayer = allLayerNeurons[l + 1];
                
                currentLayer.forEach(fromNeuron => {
                    nextLayer.forEach(toNeuron => {
                        connections.push({
                            from: fromNeuron,
                            to: toNeuron,
                            weight: Math.random() - 0.5
                        });
                    });
                });
            }
        }
        
        // Fractal System
        function drawFractal(x, y, size, depth, angle) {
            if (depth === 0 || size < 1) return;
            
            const endX = x + Math.cos(angle) * size;
            const endY = y + Math.sin(angle) * size;
            
            const hue = (depth * 30 + time * 50) % 360;
            ctx.strokeStyle = `hsla(${hue}, 70%, 50%, ${depth / 8})`;
            ctx.lineWidth = depth * 0.5;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Recursive branches
            const branchAngle1 = angle - 0.5 + Math.sin(time * 0.02) * 0.2;
            const branchAngle2 = angle + 0.5 + Math.cos(time * 0.03) * 0.2;
            const newSize = size * (0.7 + Math.sin(time * 0.01) * 0.1);
            
            drawFractal(endX, endY, newSize, depth - 1, branchAngle1);
            drawFractal(endX, endY, newSize, depth - 1, branchAngle2);
        }
        
        // Optical Illusion Patterns
        function drawOpticalIllusion() {
            const centerX = width / 2;
            const centerY = height / 2;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            
            // Rotating spiral illusion
            for (let i = 0; i < 200; i++) {
                const angle = i * 0.1 + time * 0.02;
                const radius = i * 2 + Math.sin(time * 0.05 + i * 0.1) * 20;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                const hue = (i * 5 + time * 100) % 360;
                const alpha = Math.sin(time * 0.03 + i * 0.05) * 0.5 + 0.5;
                
                ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, 3 + Math.sin(time * 0.02 + i) * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Moiré pattern overlay
            ctx.globalCompositeOperation = 'overlay';
            for (let i = 0; i < 50; i++) {
                const radius = i * 10;
                const alpha = Math.sin(time * 0.04 + i * 0.2) * 0.3 + 0.1;
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // ASCII 3D Visualization
        function generate3DASCII() {
            const chars = '█▓▒░·∙·   ';
            const asciiDiv = document.getElementById('asciiArt');
            let ascii = '';
            
            for (let y = 0; y < 20; y++) {
                for (let x = 0; x < 40; x++) {
                    const noise = perlin.noise(x * 0.1 + time * 0.01, y * 0.1 + time * 0.01);
                    const depth = Math.sin(x * 0.1 + time * 0.02) * Math.cos(y * 0.1 + time * 0.03);
                    const value = (noise + depth + 1) / 2;
                    const charIndex = Math.floor(value * chars.length);
                    ascii += chars[Math.min(charIndex, chars.length - 1)];
                }
                ascii += '\n';
            }
            
            asciiDiv.textContent = ascii;
        }
        
        // Perlin Flow Field
        function drawPerlinFlow() {
            const flowField = [];
            const cols = Math.floor(width / (20 / zoomLevel));
            const rows = Math.floor(height / (20 / zoomLevel));
            
            // Generate flow field
            for (let x = 0; x < cols; x++) {
                flowField[x] = [];
                for (let y = 0; y < rows; y++) {
                    const angle = perlin.noise(x * 0.1 * zoomLevel, y * 0.1 * zoomLevel, time * 0.01 * speed) * Math.PI * 4;
                    flowField[x][y] = angle;
                }
            }
            
            // Audio influence on particle count
            let currentParticleCount = particleCount;
            if (audioEnabled && frequencyData) {
                const avgFreq = frequencyData.reduce((a, b) => a + b) / frequencyData.length;
                currentParticleCount = Math.floor(particleCount * (0.5 + avgFreq / 255));
            }
            
            // Draw flowing particles
            ctx.globalCompositeOperation = 'screen';
            for (let i = 0; i < currentParticleCount; i++) {
                const x = (i * 137.508) % width;
                const y = (i * 41.23 + time * 50 * speed) % height;
                const colIndex = Math.floor(x / (20 / zoomLevel));
                const rowIndex = Math.floor(y / (20 / zoomLevel));
                
                if (flowField[colIndex] && flowField[colIndex][rowIndex]) {
                    const angle = flowField[colIndex][rowIndex];
                    const length = 15 * zoomLevel;
                    const endX = x + Math.cos(angle) * length;
                    const endY = y + Math.sin(angle) * length;
                    
                    const colorIndex = Math.floor((angle + Math.PI) / (Math.PI * 2) * colorPalettes[currentPalette].colors.length);
                    const alpha = Math.sin(time * 0.01 * speed + i * 0.1) * 0.3 + 0.2;
                    
                    ctx.strokeStyle = getColor(colorIndex, alpha);
                    ctx.lineWidth = 1 * zoomLevel;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            }
        }
        
        // Particle Physics Mode
        function drawParticlePhysics() {
            // Update audio data
            if (audioEnabled && analyser) {
                analyser.getByteFrequencyData(frequencyData);
            }
            
            // Add new particles if needed
            while (particles.length < particleCount) {
                particles.push(new Particle());
            }
            
            // Remove excess particles
            if (particles.length > particleCount) {
                particles.splice(particleCount);
            }
            
            ctx.globalCompositeOperation = 'screen';
            
            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.update();
                particle.draw();
                
                // Remove dead particles
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Draw connections between nearby particles
            ctx.strokeStyle = getColor(0, 0.1);
            ctx.lineWidth = 0.5;
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length && j < i + 10; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 80) {
                        const alpha = 1 - dist / 80;
                        ctx.strokeStyle = getColor(Math.floor(dist / 20), alpha * 0.3);
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }
        }
        
        // Plasma Effect
        function drawPlasma() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            
            const t = time * 0.02 * speed;
            
            for (let x = 0; x < width; x += 2) {
                for (let y = 0; y < height; y += 2) {
                    const value1 = Math.sin(x * 0.01 + t);
                    const value2 = Math.sin(y * 0.01 + t * 1.3);
                    const value3 = Math.sin((x + y) * 0.01 + t * 0.8);
                    const value4 = Math.sin(Math.sqrt(x * x + y * y) * 0.01 + t * 1.5);
                    
                    let plasma = (value1 + value2 + value3 + value4) / 4;
                    
                    // Audio influence
                    if (audioEnabled && frequencyData) {
                        const freqIndex = Math.floor((x / width) * frequencyData.length);
                        const freq = frequencyData[freqIndex] / 255;
                        plasma += freq * 0.5;
                    }
                    
                    const colorIndex = Math.floor(((plasma + 1) / 2) * colorPalettes[currentPalette].colors.length);
                    const color = colorPalettes[currentPalette].colors[colorIndex % colorPalettes[currentPalette].colors.length];
                    
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    
                    const index = (y * width + x) * 4;
                    data[index] = r;
                    data[index + 1] = g;
                    data[index + 2] = b;
                    data[index + 3] = 255;
                    
                    // Fill 2x2 block for performance
                    if (x + 1 < width) {
                        const index2 = (y * width + x + 1) * 4;
                        data[index2] = r;
                        data[index2 + 1] = g;
                        data[index2 + 2] = b;
                        data[index2 + 3] = 255;
                    }
                    if (y + 1 < height) {
                        const index3 = ((y + 1) * width + x) * 4;
                        data[index3] = r;
                        data[index3 + 1] = g;
                        data[index3 + 2] = b;
                        data[index3 + 3] = 255;
                        
                        if (x + 1 < width) {
                            const index4 = ((y + 1) * width + x + 1) * 4;
                            data[index4] = r;
                            data[index4 + 1] = g;
                            data[index4 + 2] = b;
                            data[index4 + 3] = 255;
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Neural Network Visualization
        function drawNeuralNetwork() {
            if (neurons.length === 0) initNeuralNetwork();
            
            // Update audio data
            if (audioEnabled && analyser) {
                analyser.getByteFrequencyData(frequencyData);
            }
            
            // Draw connections first
            ctx.strokeStyle = getColor(0, 0.1);
            ctx.lineWidth = 0.5;
            connections.forEach(conn => {
                if (conn.from && conn.to) {
                    const alpha = Math.abs(conn.weight) * conn.from.activation * conn.to.activation;
                    ctx.strokeStyle = getColor(conn.from.layer, alpha * 0.3);
                    ctx.beginPath();
                    ctx.moveTo(conn.from.x, conn.from.y);
                    ctx.lineTo(conn.to.x, conn.to.y);
                    ctx.stroke();
                }
            });
            
            // Update and draw neurons
            neurons.forEach(neuron => {
                neuron.update();
                neuron.draw();
            });
            
            // Add data flow visualization
            if (Math.random() > 0.95) {
                const startNeuron = neurons[Math.floor(Math.random() * 8)]; // Input layer
                ctx.fillStyle = getColor(4, 0.8);
                ctx.beginPath();
                ctx.arc(startNeuron.x, startNeuron.y, 15, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Interactive influence
        function applyInteractiveForce() {
            const influence = 100;
            const dx = mouseX - width / 2;
            const dy = mouseY - height / 2;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < influence) {
                // Add visual feedback for interaction
                ctx.save();
                ctx.translate(mouseX, mouseY);
                ctx.globalCompositeOperation = 'difference';
                
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2 + time * 0.1;
                    const radius = (influence - distance) * 0.5;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    ctx.fillStyle = `hsla(${time * 5 % 360}, 100%, 50%, 0.3)`;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // Main animation loop
        function animate() {
            time += speed;
            
            // Clear with dynamic fade effect
            const fadeAmount = mode === 5 ? 0.8 : 0.05; // Plasma needs more clearing
            ctx.fillStyle = `rgba(0, 0, 0, ${fadeAmount})`;
            ctx.fillRect(0, 0, width, height);
            
            ctx.globalCompositeOperation = 'source-over';
            
            // Update UI
            const modes = ['Perlin Flow', 'Fractals', 'Optical Illusions', 'ASCII 3D', 'Particle Physics', 'Plasma', 'Neural Network'];
            document.getElementById('mode').textContent = modes[mode];
            
            if (!evolution) return requestAnimationFrame(animate);
            
            // Save frame for recording
            if (isRecording && recordedFrames.length < 300) { // Max 10 seconds at 30fps
                recordedFrames.push(canvas.toDataURL());
            }
            
            // Apply zoom transformation
            if (zoomLevel !== 1.0) {
                ctx.save();
                ctx.scale(zoomLevel, zoomLevel);
                ctx.translate((width * (1 - zoomLevel)) / (2 * zoomLevel), (height * (1 - zoomLevel)) / (2 * zoomLevel));
            }
            
            // Render current mode
            switch (mode) {
                case 0:
                    drawPerlinFlow();
                    break;
                case 1:
                    const fractalDepth = 4 + Math.floor(complexity / 2);
                    const branches = 3 + Math.floor(complexity / 3);
                    for (let i = 0; i < branches; i++) {
                        const startX = width * (0.2 + i * 0.6 / branches);
                        const startY = height * 0.8;
                        const angle = -Math.PI / 2 + (i - branches / 2) * 0.3;
                        drawFractal(startX, startY, 80 + complexity * 10, fractalDepth, angle);
                    }
                    break;
                case 2:
                    drawOpticalIllusion();
                    break;
                case 3:
                    drawPerlinFlow();
                    generate3DASCII();
                    break;
                case 4:
                    drawParticlePhysics();
                    break;
                case 5:
                    drawPlasma();
                    break;
                case 6:
                    drawNeuralNetwork();
                    break;
            }
            
            if (zoomLevel !== 1.0) {
                ctx.restore();
            }
            
            // Apply interactive effects
            applyInteractiveForce();
            
            requestAnimationFrame(animate);
        }
        
        // Initialize sliders and controls
        function setupControls() {
            // Speed slider
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            speedSlider.addEventListener('input', (e) => {
                speed = parseFloat(e.target.value);
                speedValue.textContent = speed.toFixed(1);
            });
            
            // Complexity slider
            const complexitySlider = document.getElementById('complexitySlider');
            const complexityValue = document.getElementById('complexityValue');
            complexitySlider.addEventListener('input', (e) => {
                complexity = parseInt(e.target.value);
                complexityValue.textContent = complexity;
            });
            
            // Particle slider
            const particleSlider = document.getElementById('particleSlider');
            const particleValue = document.getElementById('particleValue');
            particleSlider.addEventListener('input', (e) => {
                particleCount = parseInt(e.target.value);
                particleValue.textContent = particleCount;
                if (mode === 4) initParticles(); // Reinitialize if in particle mode
            });
            
            // Zoom slider
            const zoomSlider = document.getElementById('zoomSlider');
            const zoomValue = document.getElementById('zoomValue');
            zoomSlider.addEventListener('input', (e) => {
                zoomLevel = parseFloat(e.target.value);
                zoomValue.textContent = zoomLevel.toFixed(1);
            });
            
            // Audio toggle
            document.getElementById('audioToggle').addEventListener('click', () => {
                if (!audioEnabled) {
                    setupAudio();
                } else {
                    audioEnabled = false;
                    if (audioContext) audioContext.close();
                    document.getElementById('audioToggle').textContent = '🎵 Audio: OFF';
                }
            });
            
            // Record button
            document.getElementById('recordBtn').addEventListener('click', () => {
                if (!isRecording) {
                    isRecording = true;
                    recordedFrames = [];
                    document.getElementById('recordBtn').textContent = '⏹ Stop';
                } else {
                    isRecording = false;
                    document.getElementById('recordBtn').textContent = '📹 Record';
                    exportRecording();
                }
            });
            
            // Save button
            document.getElementById('saveBtn').addEventListener('click', saveImage);
        }
        
        // Export recording as GIF-like data
        function exportRecording() {
            if (recordedFrames.length === 0) return;
            
            const zip = recordedFrames.map((frame, index) => {
                return `data:image/png;base64,${frame.split(',')[1]}`;
            });
            
            // Create download link for frames (simplified - in real implementation would create GIF)
            const blob = new Blob([JSON.stringify(zip)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `generative_art_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Save current image
        function saveImage() {
            const link = document.createElement('a');
            link.download = `digital_consciousness_${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }
        
        // Event listeners
        window.addEventListener('resize', resizeAll);
        
        window.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            cursor.style.left = mouseX - 10 + 'px';
            cursor.style.top = mouseY - 10 + 'px';
        });
        
        window.addEventListener('click', (e) => {
            // Add particles at click location in particle mode
            if (mode === 4) {
                for (let i = 0; i < 10; i++) {
                    particles.push(new Particle(mouseX, mouseY));
                }
            }
        });
        
        window.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    mode = (mode + 1) % 7;
                    if (mode === 4) initParticles();
                    if (mode === 6) initNeuralNetwork();
                    break;
                case 'Escape':
                    time = 0;
                    ctx.clearRect(0, 0, width, height);
                    particles = [];
                    neurons = [];
                    connections = [];
                    break;
                case 'KeyP':
                    evolution = !evolution;
                    break;
                case 'KeyR':
                    currentPalette = Math.floor(Math.random() * colorPalettes.length);
                    updateColorPalette();
                    break;
                case 'KeyF':
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        document.documentElement.requestFullscreen();
                    }
                    break;
                case 'Digit1':
                    mode = 0;
                    break;
                case 'Digit2':
                    mode = 1;
                    break;
                case 'Digit3':
                    mode = 2;
                    break;
                case 'Digit4':
                    mode = 3;
                    generate3DASCII();
                    break;
                case 'Digit5':
                    mode = 4;
                    initParticles();
                    break;
                case 'Digit6':
                    mode = 5;
                    break;
                case 'Digit7':
                    mode = 6;
                    initNeuralNetwork();
                    break;
            }
        });
        
        // Tab System
        function switchTab(tabName) {
            currentTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.tab === tabName) {
                    tab.classList.add('active');
                }
            });
            
            // Update visual sections
            document.querySelectorAll('.visual-section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById(tabName + 'Section').classList.add('active');
            
            // Update controls
            document.getElementById('canvasControls').style.display = tabName === 'canvas' ? 'block' : 'none';
            document.getElementById('domControls').style.display = 
                ['dom', 'matrix', 'geometric', 'hybrid'].includes(tabName) ? 'block' : 'none';
            
            // Initialize specific visuals
            switch(tabName) {
                case 'dom':
                    initDOMVisuals();
                    break;
                case 'matrix':
                    initMatrixRain();
                    break;
                case 'geometric':
                    initGeometricVisuals();
                    break;
                case 'hybrid':
                    initHybridVisuals();
                    break;
            }
        }
        
        // DOM Visuals
        function initDOMVisuals() {
            const container = document.getElementById('domVisual');
            container.innerHTML = '';
            domElements = [];
            
            for (let i = 0; i < domElementCount; i++) {
                createDOMElement(container);
            }
        }
        
        function createDOMElement(container) {
            const element = document.createElement('div');
            element.className = 'floating-element';
            element.style.left = Math.random() * window.innerWidth + 'px';
            element.style.top = Math.random() * window.innerHeight + 'px';
            element.style.width = (Math.random() * 20 + 10) + 'px';
            element.style.height = element.style.width;
            element.style.background = getColor(Math.floor(Math.random() * 5), 0.8);
            element.style.animationDuration = (Math.random() * 4 + 2) * domSpeed + 's';
            element.style.animationDelay = Math.random() * 2 + 's';
            
            // Add mouse interaction
            element.addEventListener('mouseenter', () => {
                element.style.transform = 'scale(1.5) rotate(180deg)';
                element.style.background = getColor(Math.floor(Math.random() * 5), 1);
            });
            
            element.addEventListener('mouseleave', () => {
                element.style.transform = 'scale(1) rotate(0deg)';
            });
            
            container.appendChild(element);
            domElements.push(element);
            
            // Auto-remove and recreate
            setTimeout(() => {
                if (element.parentNode && currentTab === 'dom') {
                    element.remove();
                    const index = domElements.indexOf(element);
                    if (index > -1) domElements.splice(index, 1);
                    if (domActive) createDOMElement(container);
                }
            }, (Math.random() * 10 + 5) * 1000);
        }
        
        // Matrix Rain
        function initMatrixRain() {
            const container = document.getElementById('matrixVisual');
            container.innerHTML = '';
            matrixColumns = [];
            
            const columnCount = Math.floor(window.innerWidth / 20);
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()_+-=[]{}|;:,.<>?';
            
            for (let i = 0; i < columnCount; i++) {
                createMatrixColumn(container, i * 20, chars);
            }
        }
        
        function createMatrixColumn(container, x, chars) {
            const columnHeight = Math.floor(window.innerHeight / 20);
            
            for (let y = 0; y < columnHeight; y++) {
                const char = document.createElement('div');
                char.className = 'matrix-rain';
                char.textContent = chars[Math.floor(Math.random() * chars.length)];
                char.style.left = x + 'px';
                char.style.top = (y * 20 - 100) + 'px';
                char.style.animationDuration = (Math.random() * 3 + 2) + 's';
                char.style.animationDelay = Math.random() * 2 + 's';
                char.style.opacity = Math.random() * 0.8 + 0.2;
                
                container.appendChild(char);
                matrixColumns.push(char);
                
                // Update character periodically
                setInterval(() => {
                    if (currentTab === 'matrix') {
                        char.textContent = chars[Math.floor(Math.random() * chars.length)];
                        char.style.opacity = Math.random() * 0.8 + 0.2;
                    }
                }, Math.random() * 1000 + 500);
            }
        }
        
        // Geometric Visuals
        function initGeometricVisuals() {
            const container = document.getElementById('geometricVisual');
            
            // Add dynamic particles
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle-dom';
                particle.style.left = Math.random() * window.innerWidth + 'px';
                particle.style.top = Math.random() * window.innerHeight + 'px';
                particle.style.background = getColor(Math.floor(Math.random() * 5), 0.8);
                particle.style.setProperty('--dx', (Math.random() - 0.5) * 500 + 'px');
                particle.style.setProperty('--dy', (Math.random() - 0.5) * 500 + 'px');
                particle.style.animationDelay = Math.random() * 8 + 's';
                
                container.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode && currentTab === 'geometric') {
                        particle.remove();
                        if (domActive) initGeometricVisuals();
                    }
                }, 8000);
            }
        }
        
        // Hybrid Visuals (Canvas + DOM)
        function initHybridVisuals() {
            hybridCanvas.width = window.innerWidth;
            hybridCanvas.height = window.innerHeight;
            
            const container = document.getElementById('hybridDom');
            container.innerHTML = '';
            
            // Add some DOM elements
            for (let i = 0; i < 20; i++) {
                createDOMElement(container);
            }
            
            // Start hybrid animation
            animateHybrid();
        }
        
        function animateHybrid() {
            if (currentTab !== 'hybrid') return;
            
            // Clear canvas with fade
            hybridCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            hybridCtx.fillRect(0, 0, hybridCanvas.width, hybridCanvas.height);
            
            // Draw canvas elements
            hybridCtx.globalCompositeOperation = 'screen';
            for (let i = 0; i < 100; i++) {
                const x = Math.sin(time * 0.01 + i * 0.1) * 200 + hybridCanvas.width / 2;
                const y = Math.cos(time * 0.01 + i * 0.1) * 200 + hybridCanvas.height / 2;
                
                hybridCtx.fillStyle = getColor(i % 5, 0.5);
                hybridCtx.beginPath();
                hybridCtx.arc(x, y, 3, 0, Math.PI * 2);
                hybridCtx.fill();
            }
            
            requestAnimationFrame(animateHybrid);
        }
        
        // Setup DOM controls
        function setupDOMControls() {
            // Count slider
            const domCountSlider = document.getElementById('domCountSlider');
            const domCountValue = document.getElementById('domCountValue');
            domCountSlider.addEventListener('input', (e) => {
                domElementCount = parseInt(e.target.value);
                domCountValue.textContent = domElementCount;
                document.getElementById('domElementCount').textContent = domElementCount;
                if (currentTab === 'dom') initDOMVisuals();
            });
            
            // Speed slider
            const domSpeedSlider = document.getElementById('domSpeedSlider');
            const domSpeedValue = document.getElementById('domSpeedValue');
            domSpeedSlider.addEventListener('input', (e) => {
                domSpeed = parseFloat(e.target.value);
                domSpeedValue.textContent = domSpeed.toFixed(1);
            });
            
            // Toggle button
            document.getElementById('domToggle').addEventListener('click', () => {
                domActive = !domActive;
                document.getElementById('domToggle').textContent = `🎮 DOM: ${domActive ? 'Active' : 'Paused'}`;
            });
            
            // Reset button
            document.getElementById('resetDom').addEventListener('click', () => {
                switch(currentTab) {
                    case 'dom':
                        initDOMVisuals();
                        break;
                    case 'matrix':
                        initMatrixRain();
                        break;
                    case 'geometric':
                        initGeometricVisuals();
                        break;
                    case 'hybrid':
                        initHybridVisuals();
                        break;
                }
            });
        }
        
        // Enhanced resize function
        function resizeAll() {
            resize();
            if (hybridCanvas) {
                hybridCanvas.width = window.innerWidth;
                hybridCanvas.height = window.innerHeight;
            }
        }
        
        // Initialize
        resizeAll();
        setupControls();
        setupDOMControls();
        initializeColorPalettes();
        initParticles();
        
        // Setup tab system
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                switchTab(tab.dataset.tab);
            });
        });
        
        animate();
        
        // Consciousness pulse - enhanced with audio responsiveness
        setInterval(() => {
            let pulseChance = 0.95;
            
            // Increase pulse frequency with audio
            if (audioEnabled && frequencyData) {
                const avgFreq = frequencyData.reduce((a, b) => a + b) / frequencyData.length / 255;
                pulseChance = 0.95 - avgFreq * 0.3;
            }
            
            if (Math.random() > pulseChance) {
                ctx.save();
                ctx.globalCompositeOperation = 'difference';
                ctx.fillStyle = getColor(Math.floor(Math.random() * colorPalettes[currentPalette].colors.length), 0.1);
                ctx.fillRect(0, 0, width, height);
                ctx.restore();
            }
        }, 100);
        
    </script>
</body>
</html>
